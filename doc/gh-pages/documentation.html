<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Tempus" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

        <title>Tempus</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">

          <h1 id="project_title">Tempus</h1>

          <a href="index.html">About</a> | <a href="documentation.html">Documentation</a> | <a href="installation.html">Installation</a>

            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

<h3>Documentation</h3>

<p>Tempus is designed around a core set of C++ classes based on boost::graph. Main classes processed by TempusV2 are:</p>
<ul>
    <li>Tempus::Road::Graph representing the road graph</li>
    <li>Tempus::PublicTransport::Graph representing a public transport graph</li>
    <li>Tempus::POI representing points of interest on the road graph</li>
    <li>Tempus::Multimodal::Graph which is a wrapper around a road graph, public transport graphs and POIs</li>
</ul>

<p>The three graph types (road, public transport and multimodal) model boost::graph concepts of graphs.</p>

<p>These graphs are filled up with data coming from a PostgreSQL/PostGIS database. Please refer to the Db namespace to see available functions. Especially have a look at the Tempus::PQImporter class (<code>src/core/pgsql_importer.hh</code>).</p>

<p>The Tempus SQL schema can be found in <code>src/loader/tempus/sql/tempus.sql</code></p>

<p>Path planning algorithms are designed to be written as user plugins. The Plugin base class (<code>src/core/plugin.hh</code>) gives access to some callbacks. Please have a look at the three different sample plugins shipped with TempusV2: Tempus::RoadPlugin (<code>src/plugins/sample_road_plugin</code>), Tempus::PtPlugin (<code>src/plugins/sample_pt_plugin</code>) and Tempus::MultiPlugin (<code>src/plugins/sample_multi_plugin/</code>).  </p>

<p>User plugins respond to path planning requests stored in the Request (<code>src/core/request.hh</code>)class and should return one or more roadmaps (<code>src/core/roadmap.hh</code>).

<p>The internal API is exposed to other programs and languages through a WPS server.</p>

<h4>C++ API</h4>

<p>A detailed description of the <a href="../api/html/index.html">C++ API documentation</a> can be found (generated by Doxygen)</p>

<h4>Developer manual</h4>

<p>A developer manual is also <a href="../user/Manuel_utilisation.odt">available</a> (French only for now).</p>

<h4>WPS server</h4>

<p>A WPS server is part of Tempus. It will load the user plugins as well as road and public transport data found in a given PostgreSQL/PostGIS database and allows a user to request path planning through a web server.</p>

<p>The WPS server uderstands XML requests. Those can be written directly, using a python script or using QGIS <i>via</i> the provided plugin.</p>

<h5>Python generated requests</h5>

<p>Communication with the WPS server can be done through the Tempus Python module (<code>src/python/tempus_request.py</code>). These are convenience functions on top of WPS HTTP communication and XML parsing.</p>

<p>An example of such scripts can be found in <code>src/batch/random_patch.py</code></p>

<p>The core of this script is a call to TempusRequest.request, where plugin and query options can be set. For instance :</p>
<pre>
  result = tempus.request( plugin_name = "sample_road_plugin",
                           plugin_options = { 'prepare_result' : True },
                           origin = dep,
                           criteria = [Cost.Distance, Cost.NumberOfChanges],
                           steps = [RequestStep(destination = arr)] )
</pre>


<h5>QGIS generated requests</h5>

<p>A client for QGIS is shipped with Tempus. It can be installed as a QGIS Python plugin. Once activated, the user interface displayed uses different tabs for each step of a request.</p>

<p>It first requires a WPS server to connect to.</p>

<img src="images/qgis_1.png"/>

<p>Once connected, the user has to select the plugin to use and the corresponding options.</p>

<img src="images/qgis_2.png"/>

<p>The request tab allows then to express the multimodal path planning request. Intermediary steps can be added dynamically. For now, coordinates are filled by a mouse click on the QGIS canvas, no geocoding is done.</p>

<img src="images/qgis_3.png"/>

<p>Once the path has been computed, QGIS will display a new vector layer with the corresponding path. The 'roadmap' tab gives details of the roadmap returned by the plugin, as well as a profile of altitutes along the way, if available within the database.</p>

<img src="images/qgis_4.png"/>

<img src="images/qgis_5.png"/>

<p>Plugin developers can access user-defined metrics through the 'Performances' tab.</p>

<p>Every path planning request is saved on disk and can be accessed later on, with the last tab. It also allows to import requests stored on user history files (the sample batch script <code>random_batch.py</code> creates such a file).</p>

<img src="images/qgis_6.png"/>

<h4>Data loader</h4>

<p>Tempus is shipped with a data loader which comes as a Python application with SQL scripts. It can be used to populate a Tempus PostgreSQL/PostGIS database with data from an external format.</p>

<p>Supported formats supported so far are:</p>
<ul>
<li>TomTom multinet (2011.3)</li>
<li>NavTeq (2008.3, 2009.3)</li>
<li>OpenStreetMap (CloudMade shapefiles and .osm through osm2shp++)</li>
<li>GTFS</li>
</ul>

<p>For OpenStreetMap, importing from raw .osm files is possible in two steps: convert the .osm file to a .shp and then use the loader. Conversion from .osm to .shp can be done with the <code>osm2shp++</code> tool provided by Tempus.</p>

<p>You can refer to <a href="../README_loader.txt">this document</a> that describes how the loader is used to build the test database.</p>
      </section>
    </div>

  </body>
</html>
